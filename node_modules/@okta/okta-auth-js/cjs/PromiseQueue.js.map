{"version":3,"sources":["../../lib/PromiseQueue.ts"],"names":["PromiseQueue","constructor","queue","running","push","method","thisObject","args","Promise","resolve","reject","run","length","queueItem","shift","res","apply","then","finally"],"mappings":";;;;AAgBA;;AAhBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAYA,MAAMA,YAAN,CAAmB;AAIjBC,EAAAA,WAAW,GAAG;AACZ,SAAKC,KAAL,GAAa,EAAb;AACA,SAAKC,OAAL,GAAe,KAAf;AACD,GAPgB,CASjB;AACA;AACA;;;AACAC,EAAAA,IAAI,CAACC,MAAD,EAAqBC,UAArB,EAAyC,GAAGC,IAA5C,EAAyD;AAC3D,WAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC,WAAKR,KAAL,CAAWE,IAAX,CAAgB;AACdC,QAAAA,MADc;AAEdC,QAAAA,UAFc;AAGdC,QAAAA,IAHc;AAIdE,QAAAA,OAJc;AAKdC,QAAAA;AALc,OAAhB;AAOA,WAAKC,GAAL;AACD,KATM,CAAP;AAUD;;AAEDA,EAAAA,GAAG,GAAG;AACJ,QAAI,KAAKR,OAAT,EAAkB;AAChB;AACD;;AACD,QAAI,KAAKD,KAAL,CAAWU,MAAX,KAAsB,CAA1B,EAA6B;AAC3B;AACD;;AACD,SAAKT,OAAL,GAAe,IAAf;AACA,QAAIU,SAAS,GAAG,KAAKX,KAAL,CAAWY,KAAX,EAAhB;AACA,QAAIC,GAAG,GAAGF,SAAS,CAACR,MAAV,CAAiBW,KAAjB,CAAuBH,SAAS,CAACP,UAAjC,EAA6CO,SAAS,CAACN,IAAvD,CAAV;;AACA,QAAI,qBAAUQ,GAAV,CAAJ,EAAoB;AAClBA,MAAAA,GAAG,CAACE,IAAJ,CAASJ,SAAS,CAACJ,OAAnB,EAA4BI,SAAS,CAACH,MAAtC,EAA8CQ,OAA9C,CAAsD,MAAM;AAC1D,aAAKf,OAAL,GAAe,KAAf;AACA,aAAKQ,GAAL;AACD,OAHD;AAID,KALD,MAKO;AACLE,MAAAA,SAAS,CAACJ,OAAV,CAAkBM,GAAlB;AACA,WAAKZ,OAAL,GAAe,KAAf;AACA,WAAKQ,GAAL;AACD;AACF;;AA7CgB;;eAgDJX,Y","sourcesContent":["/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and limitations under the License.\n */\n\n// Implements a queue for synchronous or asynchronous methods\n// Methods will be wrapped in a promise and execute sequentially\n// This can be used to prevent concurrent calls to a single method or a set of methods\n\nimport { isPromise } from './util';\n\ninterface QueueItem {\n  method: () => void;\n  thisObject: object;\n  args: any[];\n  resolve: (value?: unknown) => void;\n  reject: (reason?: unknown) => void;\n}\n\nclass PromiseQueue {\n  queue: QueueItem[];\n  running: boolean;\n\n  constructor() {\n    this.queue = [];\n    this.running = false;\n  }\n\n  // Returns a promise\n  // If the method is synchronous, it will resolve when the method completes\n  // If the method returns a promise, it will resolve (or reject) with the value from the method's promise\n  push(method: () => void, thisObject: object, ...args: any[]) {\n    return new Promise((resolve, reject) => {\n      this.queue.push({\n        method,\n        thisObject,\n        args,\n        resolve,\n        reject\n      });\n      this.run();\n    });\n  }\n\n  run() {\n    if (this.running) {\n      return;\n    }\n    if (this.queue.length === 0) {\n      return;\n    }\n    this.running = true;\n    var queueItem = this.queue.shift();\n    var res = queueItem.method.apply(queueItem.thisObject, queueItem.args);\n    if (isPromise(res)) {\n      res.then(queueItem.resolve, queueItem.reject).finally(() => {\n        this.running = false;\n        this.run();\n      });\n    } else {\n      queueItem.resolve(res);\n      this.running = false;\n      this.run();\n    }\n  }\n}\n\nexport default PromiseQueue;"],"file":"PromiseQueue.js"}