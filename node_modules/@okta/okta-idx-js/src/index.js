"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js-stable/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs3/regenerator"));

var _indexOf = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/index-of"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/promise"));

var _url = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/url"));

require("core-js/modules/es.string.replace.js");

require("core-js/modules/es.regexp.exec.js");

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/asyncToGenerator"));

var _introspect = _interopRequireDefault(require("./introspect"));

var _bootstrap = _interopRequireDefault(require("./bootstrap"));

var _parsers = _interopRequireDefault(require("./parsers"));

var _client = require("./client");

/*!
 * Copyright (c) 2021-Present, Okta, Inc. and/or its affiliates. All rights reserved.
 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
 *
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *
 * See the License for the specific language governing permissions and limitations under the License.
 */
var LATEST_SUPPORTED_IDX_API_VERSION = '1.0.0';

var start = /*#__PURE__*/function () {
  var _start = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(_ref) {
    var _issuer, _issuer2;

    var clientId, domain, issuer, stateHandle, interactionHandle, version, redirectUri, state, scopes, codeChallenge, codeChallengeMethod, baseUrl, toPersist, cleanVersion, bootstrapParams, interaction_handle, _parsersForVersion, _makeIdxState, idxResponse, idxState;

    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            clientId = _ref.clientId, domain = _ref.domain, issuer = _ref.issuer, stateHandle = _ref.stateHandle, interactionHandle = _ref.interactionHandle, version = _ref.version, redirectUri = _ref.redirectUri, state = _ref.state, scopes = _ref.scopes, codeChallenge = _ref.codeChallenge, codeChallengeMethod = _ref.codeChallengeMethod;
            issuer = (_issuer = issuer) === null || _issuer === void 0 ? void 0 : _issuer.replace(/\/+$/, '');
            baseUrl = ((_issuer2 = issuer) === null || _issuer2 === void 0 ? void 0 : (0, _indexOf.default)(_issuer2).call(_issuer2, '/oauth2')) > 0 ? issuer : issuer + '/oauth2'; // org AS uses domain as AS, but we need the base url for calls

            toPersist = {
              baseUrl: baseUrl,
              clientId: clientId,
              state: state
            };

            if (!(!domain && !issuer)) {
              _context.next = 6;
              break;
            }

            return _context.abrupt("return", _promise.default.reject({
              error: 'issuer is required'
            }));

          case 6:
            if (!(!stateHandle && !clientId)) {
              _context.next = 8;
              break;
            }

            return _context.abrupt("return", _promise.default.reject({
              error: 'clientId is required'
            }));

          case 8:
            if (!(!stateHandle && !redirectUri)) {
              _context.next = 10;
              break;
            }

            return _context.abrupt("return", _promise.default.reject({
              error: 'redirectUri is required'
            }));

          case 10:
            if (!(!stateHandle && !(codeChallenge && codeChallengeMethod))) {
              _context.next = 12;
              break;
            }

            return _context.abrupt("return", _promise.default.reject({
              error: 'PKCE params (codeChallenge, codeChallengeMethod) are required'
            }));

          case 12:
            if (!domain) {
              domain = new _url.default(issuer).origin;
            }

            if (version) {
              _context.next = 15;
              break;
            }

            return _context.abrupt("return", _promise.default.reject({
              error: 'version is required'
            }));

          case 15:
            cleanVersion = (version !== null && version !== void 0 ? version : '').replace(/[^0-9a-zA-Z._-]/, '');

            if (!(cleanVersion !== version || !version)) {
              _context.next = 18;
              break;
            }

            return _context.abrupt("return", _promise.default.reject({
              error: 'invalid version supplied - version is required and uses semver syntax'
            }));

          case 18:
            if (!(!stateHandle && !interactionHandle)) {
              _context.next = 31;
              break;
            }

            _context.prev = 19;
            bootstrapParams = {
              clientId: clientId,
              baseUrl: baseUrl,
              scopes: scopes,
              redirectUri: redirectUri,
              codeChallenge: codeChallenge,
              codeChallengeMethod: codeChallengeMethod,
              state: state
            };
            _context.next = 23;
            return (0, _bootstrap.default)(bootstrapParams);

          case 23:
            interaction_handle = _context.sent;
            interactionHandle = interaction_handle;
            toPersist.interactionHandle = interactionHandle;
            _context.next = 31;
            break;

          case 28:
            _context.prev = 28;
            _context.t0 = _context["catch"](19);
            return _context.abrupt("return", _promise.default.reject({
              error: _context.t0
            }));

          case 31:
            _context.prev = 31;
            _parsersForVersion = (0, _parsers.default)(version), _makeIdxState = _parsersForVersion.makeIdxState;
            _context.next = 35;
            return (0, _introspect.default)({
              domain: domain,
              interactionHandle: interactionHandle,
              stateHandle: stateHandle,
              version: version
            }).catch(function (err) {
              return _promise.default.reject({
                error: 'introspect call failed',
                // Transform all errors into an IdX State object.
                // This allows IdX based errors (messages) to optionally proceed with remediation forms
                details: _makeIdxState(err, toPersist)
              });
            });

          case 35:
            idxResponse = _context.sent;
            idxState = _makeIdxState(idxResponse, toPersist);
            return _context.abrupt("return", idxState);

          case 40:
            _context.prev = 40;
            _context.t1 = _context["catch"](31);
            return _context.abrupt("return", _promise.default.reject({
              error: _context.t1
            }));

          case 43:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[19, 28], [31, 40]]);
  }));

  function start(_x) {
    return _start.apply(this, arguments);
  }

  return start;
}();

var _parsersForVersion2 = (0, _parsers.default)(LATEST_SUPPORTED_IDX_API_VERSION),
    makeIdxState = _parsersForVersion2.makeIdxState;

var _default = {
  start: start,
  introspect: _introspect.default,
  interact: _bootstrap.default,
  makeIdxState: makeIdxState,
  client: _client.HttpClient,
  LATEST_SUPPORTED_IDX_API_VERSION: LATEST_SUPPORTED_IDX_API_VERSION
};
exports.default = _default;